/*********************************************************
 * This code was written in the context of the Lightkone
 * European project.
 * Code is of the authorship of NOVA (NOVA LINCS @ DI FCT
 * NOVA University of Lisbon)
 * Author:
 * André Rosa (af.rosa@campus.fct.unl.pt
 * Under the guidance of:
 * Pedro Ákos Costa (pah.costa@campus.fct.unl.pt)
 * João Leitão (jc.leitao@fct.unl.pt)
 * (C) 2020
 *********************************************************/

#include "routing_context_private.h"

#include "data_structures/hash_table.h"

#include "protocols/discovery/framework/framework.h"
#include "protocols/routing/framework/framework.h"

#include <assert.h>

typedef enum {
    TORA_RREQ,
    TORA_UPD,
    //TORA_CLR,
    //TORA_OPT,
    //TORA_RREP,
    //TORA_RERR
} TORAControlMessageType;

typedef enum {
    UN,
    UP,
    DN
} TORALinkType;

typedef struct TORAHeight_ {
    unsigned long tau;
    uuid_t oid;
    bool r;
    unsigned short delta;
    uuid_t id;
} TORAHeight;

typedef struct TORADestEntry_ { // "j" is the current entry
    TORAHeight height;

    unsigned short mode_seq;   // Sequence number of most recent mode for "j".
   // PRO_MODE[j]    Indicates reactive/proactive mode of operation for "j".
   // OPT_MODE[j]    Indicates optimization mode of operation for "j".
   // OPT_PERIOD[j]  Indicates optimization period for "j".

   bool rt_req;     // Indicates whether a route request to "j" is pending.
   struct timespec time_upd;   // Time last UPD packet regarding "j" sent by this router.

   unsigned int num_active;
   unsigned int num_down;
   unsigned int num_up;
} TORADestEntry;

typedef struct TORADestPerNeighEntry_ {
    TORAHeight ht_neigh;
    TORALinkType link_stat;
    unsigned long time_act;
} TORADestPerNeighEntry;

typedef struct TORAState {
    hash_table* dest_table;
} TORAState;

static void TORA_ZeroHeight(TORAHeight* height, unsigned char* id) {
    height->tau = 0;
    memset(height->oid, 0, sizeof(uuid_t));
    height->r = false;
    height->delta = 0;
    uuid_copy(height->id, id);
}

static int TORA_HeightCompare(TORAHeight* h1, TORAHeight* h2) {
    assert(h1 && h2);

    if(h1->tau > h2->tau) return 1;
    else if(h1->tau < h2->tau) return -1;
    else { // tau is equal
        int cmp = uuid_compare(h1->oid,h2->oid);
        if(cmp > 0) return 1;
        else if(cmp < 0) return -1;
        else { // oid is equal
            if(h1->r > h2->r) return 1;
            else if(h1->r < h2->r) return -1;
            else { // r is equal
                if(h1->delta > h2->delta) return 1;
                else if(h1->delta < h2->delta) return -1;
                else { // delta is equal
                    return uuid_compare(h1->id,h2->id);
                }
            }
        }
    }
}

static TORALinkType TORA_LinkStat(TORAHeight* ht_neigh, TORAHeight* height) {
    if(ht_neigh == NULL) {
        return UN;
    } else if(height == NULL) {
        return DN;
    } else{
        int cmp = TORA_HeightCompare(ht_neigh, height);
        if(cmp < 0) {
            return DN;
        } else if(cmp > 0) {
            return UP;
        } else {
            assert(false);
        }
    }
}

static RoutingContextSendType ProcessDiscoveryEvent(YggEvent* ev, TORAState* state, RoutingTable* routing_table, RoutingNeighbors* neighbors, SourceTable* source_table, unsigned char* myID, struct timespec* current_time, const char* proto);

static bool getBestBiParent(RoutingNeighbors* neighbors, byte* meta_data, unsigned int meta_length, unsigned char* found_parent, double* found_route_cost, unsigned int* found_route_hops);

static RoutingContextSendType TORARoutingContextTriggerEvent(ModuleState* m_state, const char* proto, RoutingEventType event_type, void* args, RoutingTable* routing_table, RoutingNeighbors* neighbors, SourceTable* source_table, unsigned char* myID, struct timespec* current_time) {

    TORAState* state = (TORAState*)m_state->vars;

    if(event_type == RTE_ROUTE_NOT_FOUND) {
        //printf("SENDING RREQ\n");
        return SEND_INC;
    } else if(event_type == RTE_NEIGHBORS_CHANGE) {
        YggEvent* ev = args;
        ProcessDiscoveryEvent(ev, state, routing_table, neighbors, source_table, myID, current_time, proto);
        //return SEND_INC;
    } else if(event_type == RTE_SOURCE_EXPIRE) {
        //SourceEntry* entry = (SourceEntry*)args;

        // Remove
        //list* to_remove = list_init();
        //list_add_item_to_tail(to_remove, new_id(SE_getID(entry)));
        //RF_updateRoutingTable(routing_table, NULL, to_remove, current_time);
    }

    return NO_SEND;
}

static void TORARoutingContextCreateMsg(ModuleState* m_state, const char* proto, RoutingControlHeader* header, RoutingTable* routing_table, RoutingNeighbors* neighbors, SourceTable* source_table, unsigned char* myID, struct timespec* current_time, YggMessage* msg, RoutingEventType event_type, void* info) {

    if( event_type == RTE_ROUTE_NOT_FOUND ) {
        assert(info);
        RoutingHeader* header2 = info;

        byte type = 0;

        // Send RREQ
        if( uuid_compare(header2->source_id, myID) == 0 ) {
            type = TORA_RREQ;

            YggMessage_addPayload(msg, (char*)&type, sizeof(byte));

            YggMessage_addPayload(msg, (char*)header2->destination_id, sizeof(uuid_t));

            char str[UUID_STR_LEN];
            uuid_unparse(header2->destination_id, str);
            printf("GENERATING REQ to %s\n", str);
        }
        // Send RERR
        else {
            /*
            type = TORA_RERR;

            YggMessage_addPayload(msg, (char*)&type, sizeof(byte));

            byte amount = 1;
            YggMessage_addPayload(msg, (char*)&amount, sizeof(byte));

            YggMessage_addPayload(msg, (char*)header2->destination_id, sizeof(uuid_t));

            char str[UUID_STR_LEN];
            uuid_unparse(header2->destination_id, str);
            printf("GENERATING RERR to remove %s\n", str);
            */
            assert(false);
        }

    } else {
        assert(false);
    }
}

static RoutingContextSendType TORARoutingContextProcessMsg(ModuleState* m_state, const char* proto, RoutingTable* routing_table, RoutingNeighbors* neighbors, SourceTable* source_table, SourceEntry* source_entry, unsigned char* myID, struct timespec* current_time, RoutingControlHeader* header, byte* payload, unsigned short length, unsigned short src_proto, byte* meta_data, unsigned int meta_length, bool new_seq, void* state) {

    if(!new_seq) {
        return NO_SEND; // ??
    }

    byte* ptr = payload;

    byte type = 0;
    memcpy(&type, ptr, sizeof(byte));
    ptr += sizeof(byte);

    //printf("RECEIVED TORA TYPE: %d\n", type);

    if( type == TORA_RREQ ) {
        uuid_t destination_id;
        memcpy(destination_id, ptr, sizeof(uuid_t));
        ptr += sizeof(uuid_t);

        // Finding the best parent does not matter in tora. Just check if it is bi?

        uuid_t found_parent = {0};
        double found_route_cost = 0.0;
        unsigned int found_route_hops = 0;
        bool found = getBestBiParent(neighbors, meta_data, meta_length, found_parent, &found_route_cost, &found_route_hops);
        if( found ) {
            // Update Routing Table
            //addRoute(SE_getID(source_entry), found_parent, found_route_cost, found_route_hops, neighbors, routing_table, current_time, proto);

            if( uuid_compare(destination_id, myID) == 0 ) {

                printf("I'm the wanted destination! SEND RREP\n");

                // return SEND_INC; // SEND RREP
            }
        }
    } else {
        assert(false);
    }

    return NO_SEND;
}

void TORARoutingDestroy(ModuleState* m_state) {
    TORAState* state = (TORAState*)m_state->vars;

    hash_table_item* hit = NULL;
    void* iterator = NULL;
    while ( (hit = hash_table_iterator_next(state->neighbors_attrs, &iterator)) ) {
        hash_table* ht = (hash_table*)hit->value;
        hash_table_delete(ht);
        hit->value = NULL;
    }
    hash_table_delete(state->neighbors_attrs);
    free(state);
}

RoutingContext* TORARoutingContext() {

    TORAState* state = malloc(sizeof(TORAState));
    state->neighbors_attrs = hash_table_init((hashing_function)&uuid_hash, (comparator_function)&equalID);

    return newRoutingContext(
        "TORA",
        NULL,
        state,
        NULL, //&TORARoutingContextInit,
        &TORARoutingContextTriggerEvent,
        &TORARoutingContextCreateMsg,
        &TORARoutingContextProcessMsg,
        &TORARoutingDestroy
    );
}

static bool getBestBiParent(RoutingNeighbors* neighbors, byte* meta_data, unsigned int meta_length, unsigned char* found_parent, double* found_route_cost, unsigned int* found_route_hops) {

    uuid_t min_parent_id = {0};
    double min_route_cost = 0.0;
    unsigned int min_route_hops = 0;
    bool first = true;


    byte* ptr2 = meta_data;

    uuid_t source_id;
    memcpy(source_id, ptr2, sizeof(uuid_t));
    ptr2 += sizeof(uuid_t);

    byte n_copies = 0;
    memcpy(&n_copies, ptr2, sizeof(byte));
    ptr2 += sizeof(byte);

    for(int i = 0; i < n_copies; i++) {
        uuid_t parent_id;
        memcpy(parent_id, ptr2, sizeof(uuid_t));
        ptr2 += sizeof(uuid_t);

        ptr2 += sizeof(struct timespec);

        unsigned short context_length = 0;
        memcpy(&context_length, ptr2, sizeof(unsigned short));
        ptr2 += sizeof(unsigned short);

        byte context[context_length];
        memcpy(context, ptr2, context_length);
        ptr2 += context_length;

        // parse context
        double route_cost = 0.0;
        unsigned int route_hops = 0;
        bool has_cost = false;
        bool has_hops = false;

        byte* ptr3 = context;
        unsigned int read = 0;
        while( read < context_length ) {
            char key[101];
            unsigned int key_len = strlen((char*)ptr3)+1;
            memcpy(key, ptr3, key_len);
            ptr3 += key_len;
            read += key_len;

            byte len = 0;
            memcpy(&len, ptr3, sizeof(byte));
            ptr3 += sizeof(byte);
            read += sizeof(byte);

            byte value[len];
            memcpy(value, ptr3, len);
            ptr3 += len;
            read += len;

            if(strcmp(key, "route_cost") == 0) {
                assert(len == sizeof(double));
                route_cost = *((double*)value);
                //printf("context: %s -> (%u bytes, %f)\n", key, len, route_cost);
                has_cost = true;
            } else if(strcmp(key, "hops") == 0) {
                assert(len == sizeof(byte));
                route_hops = *((byte*)value);
                //printf("context: %s -> (%u bytes, %u)\n", key, len, route_hops);
                has_hops = true;
            } else {
                // debug
                //printf("context: %s -> (%u bytes, - )\n", key, len);
            }
        }

        RoutingNeighborsEntry* neigh = RN_getNeighbor(neighbors, parent_id);
        if( neigh && RNE_isBi(neigh) && has_cost && has_hops ) { // parent is bi
            route_cost += RNE_getTxCost(neigh);
            //route_hops += 1;

            if( route_cost < min_route_cost || (route_cost == min_route_cost && route_hops < min_route_hops) || first ) {
                first = false;
                min_route_cost = route_cost;
                min_route_hops = route_hops;
                uuid_copy(min_parent_id, parent_id);
            }
        }
    }

    if(!first) {
        *found_route_cost = min_route_cost;
        *found_route_hops = min_route_hops;
        uuid_copy(found_parent, min_parent_id);
        return true;
    } else {
        return false;
    }

}

static void ProcessDiscoveryEvent(YggEvent* ev, TORAState* state, RoutingTable* routing_table, RoutingNeighbors* neighbors, SourceTable* source_table, unsigned char* myID, struct timespec* current_time, const char* proto) {
    assert(ev);

    unsigned short ev_id = ev->notification_id;

    bool process = ev_id == NEW_NEIGHBOR || ev_id == UPDATE_NEIGHBOR || ev_id == LOST_NEIGHBOR;
    if(process) {
        unsigned short read = 0;
        unsigned char* ptr = ev->payload;

        unsigned short length = 0;
        memcpy(&length, ptr, sizeof(unsigned short));
        ptr += sizeof(unsigned short);
        read += sizeof(unsigned short);

        YggEvent main_ev = {0};
        YggEvent_init(&main_ev, DISCOVERY_FRAMEWORK_PROTO_ID, 0);
        YggEvent_addPayload(&main_ev, ptr, length);
        ptr += length;
        read += length;

        unsigned char* ptr2 = NULL;

        uuid_t id;
        ptr2 = YggEvent_readPayload(&main_ev, ptr2, id, sizeof(uuid_t));

        bool remove = false;

        if(ev_id == NEW_NEIGHBOR) {
            RoutingNeighborsEntry* neigh = RN_getNeighbor(neighbors, id);
            assert(neigh);

            if( RNE_isBi(neigh) ) {
                hash_table* ht = hash_table_find_value(state->neighbors_attrs, id);
                assert(ht == NULL);

                ht = hash_table_init((hashing_function)&uuid_hash, (comparator_function)&equalID);

                hash_table_insert(state->neighbors_attrs, new_id(id), ht);

                TORADestPerNeighEntry* e = malloc(sizeof(TORADestPerNeighEntry));
                TORA_ZeroHeight(&e->height, id);
                e->link_stat = DN;
                hash_table_insert(ht, new_id(id), e);

                // TODO: inc num_down[j], quando j==k, i.e., agora

                // TODO: inc num_active[j], j é todos os destinos.
                // como fazer isto?



                // TODO: Adicionar à routing table

                // TODO: adicionar uma height (zero) para este neigh ( == 0) e link_stat igual a downstream

                // como saber se o rt_req é true ou false no momento da criação/descoberta do neigh? ter uma estrutura à parte que regista que se faz/recebe RREQ? Eles não exlpicam no papiro


                double cost = RNE_getTxCost(neigh);
                addRoute(id, id, cost, 1, neighbors, routing_table, current_time, proto);
            } else {
                remove = true;
            }
        } else {
            remove = true;
        }

        if(remove) {
            list* to_remove = list_init();

            //list_add_item_to_tail(to_remove, new_id(id));

            void* iterator = NULL;
            RoutingTableEntry* current_route = NULL;
            while( (current_route = RT_nextRoute(routing_table, &iterator)) ) {
                if( uuid_compare(RTE_getNextHopID(current_route), id) == 0) {
                    list_add_item_to_tail(to_remove, new_id(RTE_getDestinationID(current_route)));
                }
            }

            RF_updateRoutingTable(routing_table, NULL, to_remove, current_time);
        }
    }
}
